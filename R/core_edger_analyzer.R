#=============================================================================
# kwanlibr is a package that contains wrapper functions
# for edgeR functions.

#---------
# TO-DO
#---------
# - create testing suite?
# - changelog?
# - create runable examples in documentation?
#=============================================================================

# install dependencies

#edgeR dependencies
#' @import edgeR
#' @import rtracklayer
#' @import org.Mm.eg.db
#' @import data.table
#' @import ggrepel

#constants
IMPORTANT_TAGS <- c("gene_id", "gene_type", "gene_name")


#---------------------
# Functions
#---------------------

#' Get reference
#'
#' get_gtf(gtf, verbose) returns the reference specified by
#' the path gtf. 
#' @param gtf Absolute path to the reference. Default is the GENCODE annotation 
#' for mm10/GRCm38
#' @param verbose Set to TRUE to print number of genes in the reference
#' @return A dataframe of gene annotations with 3 columns: the ensembl 
#' `gene_id`, the `gene_type`, and `gene_name` (gene symbol)
#' @export
#' @examples
#' get_gtf(gtf='/nfs/turbo/umms-kykwan/projects/reference/gtf/gencode.vM14.primary_assembly.ERCC.annotation.gtf')

get_gtf <- function(
  gtf='/nfs/turbo/umms-kykwan/projects/reference/gtf/gencode.vM14.primary_assembly.annotation.gtf',
  verbose=FALSE
) {
  
  ## Read in reference genome for location info
  gtf <- rtracklayer::readGFF(
    gtf,
    columns=c("seqid", "start", "end"),
    tags=IMPORTANT_TAGS,
    filter=list(type=c("gene"))
  )
  
  if (verbose) {
    print(paste("Number of Rows:", nrow(gtf)))
  }
  
  return(gtf)
}


#' Perform edgeR
#'
#' perform_edger(
#' sampleTable, fileCol, idCol, condCol, batchCol, filePrefix, gtf, saveName) 
#' performs edgeR analysis on a dataframe of samples. Typically run after 
#' get_gtf, subset_samples, and label_control_samples
#' @param sampleTable A dataframe with sample data
#' @param fileCol Column name that refers to file names
#' @param idCol Column name that refers to the unique identifier of each sample
#' @param condCol Column name that refers to the experimental condition of each sample
#' @param batchCol (optional) To enable batch correction, pass a column name that 
#' refers to the batch of the sample. If NULL, no batch correction
#' @param filePrefix Prefix to add to filenames (e.g. if they are in a different
#'  directory). If NULL, search the current working directory
#' @param gtf A dataframe of the reference genome, generated by `kwanlibr::get_gtf`
#' @param saveName Filename to save edgeR tables under. Saves top 5k genes and 
#' all genes. If NULL, do not save tables.
#' @return A dataframe of the edgeR analysis
#' @export
#' @examples
#' perform_edger(smc3, idCol="Pool.Name", gtf=gtf, saveName="tables/p21_smc3_edger")

perform_edger <- function(
  sampleTable,
  fileCol="Filename", 
  idCol="Sample", 
  condCol="condition",
  batchCol=NULL,
  filePrefix=NULL, 
  gtf=NULL,
  saveName=NULL
) {
  if (class(filePrefix) == "NULL") {
    filePrefix <- getwd()
  }
  filePrefix <- gsub("/+$", "", filePrefix)
  
  if (class(gtf) == "NULL") {
    gtf <- kwanlibr::get_gtf()
  }
    
  if(class(batchCol) == "NULL"){
    sampleTable <- data.frame(
      sampleName = sampleTable[[idCol]],
      files = file.path(filePrefix, sampleTable[[fileCol]]),
      condition = sampleTable[[condCol]]
    )
  }
  else{
    sampleTable <- data.frame(
      sampleName = sampleTable[[idCol]],
      files = file.path(filePrefix, sampleTable[[fileCol]]),
      condition = sampleTable[[condCol]],
      batch = sampleTable[[batchCol]]
    )
  }
  
  ## Perform analysis
  dge <- edgeR::readDGE(sampleTable, header=FALSE)
  ## remove last rows to avoid problems with edgeR as they are meta tags, not genes
  dge$counts <- head(dge$count, -5)
  ## Add in gene names to use later on
  merged_dge_genes <- merge(
    dge$counts,
    gtf,
    by.x = "row.names",
    by.y = "gene_id"
  )
  ## Column name gets lost in merge to become "Row.names"
  colnames(merged_dge_genes)[1] <- "gene_id"
  dge$genes <- merged_dge_genes[,IMPORTANT_TAGS]
  ## Remove variable to save on memory
  remove(merged_dge_genes)
  dge <- edgeR::calcNormFactors(dge)
  if(class(batchCol) == "NULL"){
    design <- model.matrix(
      ~ droplevels(sampleTable[["condition"]])
    )
  } else {
    design <- model.matrix(
      ~ sampleTable[["condition"]] + sampleTable[["batch"]]
    )
  }
  dge <- edgeR::estimateDisp(dge, design)
  fit <- edgeR::glmFit(dge, design)
  lrt <- edgeR::glmLRT(fit, coef=2)
  
  print(summary(limma::decideTests(lrt, p.value = 0.001)))
  
  if (class(saveName) != "NULL") {
    final_table <- as.data.frame(edgeR::topTags(lrt, n = nrow(dge$counts)))
    dir.create(
      dirname(saveName),
      recursive = TRUE,
      showWarnings = FALSE
    )
    write.csv(
      final_table,
      file=paste(saveName, ".csv", sep="")
    )
    write.csv(
      edgeR::topTags(lrt, n = 5000),
      file=paste(saveName, "_top5k.csv", sep="")
    ) 
  }
  
  return(lrt)
}


#' Get a subset of table rows
#'
#' subset_samples(sampleTable, col, ...) selects a subset of rows from 
#' sampleTable where the value of col is in ... 
#' @param sampleTable Table we want to subset
#' @param col Column to search
#' @param ... All other arguments are strings or regex that are selected for in
#' the column. The result is the union of these searches
#' @return A dataframe with the subset of selected rows
#' @export
#' @examples
#' subset_samples(samples, "Pool.Name", "Smc", "p21") # Selects only rows with 
#' "Smc" or "p21" in the Pool.name column

subset_samples <- function(sampleTable, col, ...) {
  return(
    sampleTable[grepl(paste(c(...), collapse="|"),
    sampleTable[[col]], perl=TRUE),]
  )
}


#' Adds a condition column which labels samples as knockout or control
#'
#' label_control_samples(sampleTable, col, pattern) labels a sample as a control if the
#' value in col matches pattern
#' @param sampleTable Table we want to annotate
#' @param col Column to search
#' @param pattern String or regex of which samples are controls
#' @return A copy of sampleTable with the new column `condition` where the value
#' is either ko or CON
#' @export
#' @examples
#' label_control_samples(smc3, "Condition", "ctrl")

label_control_samples <- function(sampleTable, col, pattern) {
  # Note: CON is purposefully all uppercase in order to ensure that it is before
  #  ko alphabetically.Otherwise, fold changes will be flipped with
  #  controls being treated as ko.
  # The levels argument specifies the order of the factors, but 
  #   manipulations outside of this function may revert the table back to
  #   default ordering, hence the uppercasing of CON.
  sampleTable$condition <- factor(
    ifelse(
      grepl(pattern, sampleTable[[col]]),
      "CON",
      "ko"
    ),
    levels = c("CON", "ko")
  )
  return(sampleTable)
}


#' Create a volcano plot
#'
#' make_volcano(lrt, figure_title, filename, figure_dir, fdr, xdiff,
#' ymax, intersect, intersect_color, label_genes) creates a volcano plot from the
#' data in lrt with title volcano_figure_title and saves it in a pdf and png 
#' under the folder figure_dir 
#' @param lrt A dataframe of the edgeR data to plot, typically generated by `perform_edger`
#' @param figure_title Title of the volcano plot (ie `Smc3 cKO`)
#' @param filename Name the plot is saved under
#' @param figure_dir Directory to save the plots under
#' @param fdr False discovery rate threshold. Genes > fdr are colored
#' @param xdiff x-axis ceiling in both directions. For example, xdiff=5 sets the
#'  x axis to -5 to 5
#' @param ymax y-axis ceiling
#' @param label_genes List of genes to label on the volcano plot
#' @keywords volcano plot
#' @import ggplot2
#' @export
#' @examples
#' make_volcano(smc3, figure_title="Smc3 cKO", filename="edger_smc3",
#' figure_dir=figure_dir)

make_volcano <- function(
  lrt,
  figure_title,
  filename,
  figure_dir,
  fdr=0.01,
  xdiff=5,
  ymax=40,
  label_genes=NULL
) {
  dir.create(figure_dir)

  # Desperately needs refactoring
  volcano_df <- edgeR::topTags(lrt, n = nrow(lrt$table))$table
  volcano_df$negLogPval <- -log10(volcano_df$PValue)

  # Create ceilings
  volcano_df$logFC <- kwanlibr::clamp(volcano_df$logFC, 
                                      lower = -xdiff, 
                                      upper = xdiff)
  volcano_df$negLogPval <- kwanlibr::clamp(volcano_df$negLogPval,
                                           lower = 0,
                                           upper = ymax)
  
  # Plot significant points on top of insignificant points
  insig.points <- subset(volcano_df, FDR > fdr)
  sig.down.points <- subset(volcano_df, FDR <= fdr & logFC < 0)
  sig.up.points <- subset(volcano_df, FDR <= fdr & logFC > 0)
  
  p <- ggplot(insig.points, aes(logFC, negLogPval)) +
    geom_point(col = 'grey', alpha = 0.1) +
    geom_point(data = sig.down.points, col = '#1a52f9') +
    geom_point(data = sig.up.points, col = '#d80303') +
    xlim(-xdiff, xdiff) +
    ylim(0, ymax) +
    ggtitle(figure_title) +
    xlab(expression(log[2]*"FoldChange")) +
    ylab(expression(-log[10]*"("*italic("P")*"-value)")) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 21),
          axis.title = element_text(size = 15),
          axis.text = element_text(size=12))

  if (!is.null(label_genes)) {
    label_df <- volcano_df[volcano_df$gene_name %in% label_genes,]
    p <- p +
    ggrepel::geom_label_repel(
      data = label_df,
      aes(logFC, negLogPval, label = gene_name),
      max.overlaps = Inf,
      box.padding = 0.5,
      # force = 4,
      size = 4,
      min.segment.length = 0,
      fill = "white",
      fontface = "italic"
      # parse = TRUE,
    ) + 
    geom_point(data=label_df, col="cyan")
  }

   kwanlibr::ggsave_vector_raster(
     filename = file.path(figure_dir, paste0('volcano_', filename)),
     width = 6, height = 6,
     plot = p
   )
  
  return(p)
}
